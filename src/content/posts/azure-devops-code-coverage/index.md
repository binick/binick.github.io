---
title: How to include code coverage in Azure DevOps pipeline?
date: 2021-01-02
author: Nicola Biancolini
description: Managing multiple reports in Azure DevOps can get complicated, let's see how MSBuild can help us.
keywords: 
  - coverlet
  - azure devops
  - msbuild
tags:
  - devops
aliases:
  - /posts/2021-01-02_azure-devops-code-coverage
cover:
  image: cover.jpg
  alt: A pug completely wrapped in a fluffy white blanket of which only the muzzle is visible
  relative: true
  caption: Photo by <a href="https://unsplash.com/@matthewhenry?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Matthew Henry</a> on <a href="https://unsplash.com/s/photos/blanket?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
---

By code coverage, we mean the action of trying to measure how much of our code has been executed by our tests.
This sound like 

{{< collapse summary="TL;DR" >}} 
> Untested code is a broken code.
Definitely a strong statement but true in a way, we don't always manage to get enough coverage.
Often this happens because we don't have time, other times because despite having written tests we are not able to read the metrics. 
{{< /collapse >}}

So, how we can "humanize" code coverage metrics? And how we can generate its?

To answer at these questions I usually use two libraries.

{{< github coverlet-coverage coverlet >}}

to gather metrics, and

{{< github danielpalme ReportGenerator >}}

for generate human-readable reports.

## How can set-up __*coverlet*__?

I usually include [coverlet.msbuild](https://www.nuget.org/packages/coverlet.msbuild/) by [MSBuild .targets Files - Visual Studio | Microsoft Docs](https://docs.microsoft.com/visualstudio/msbuild/msbuild-dot-targets-files).

``` xml
<?xml version="1.0" encoding="utf-8"?>
<Project>

  <PropertyGroup>
    <CollectCoverage>true</CollectCoverage>
    <CoverletOutputFormat>cobertura</CoverletOutputFormat>
    <CoverletOutput>$(ArtifactsCoverageDir)\$(MSBuildProjectName).xml</CoverletOutput>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.msbuild" Version="$(CoverletMSBuildVersion)" IsImplicitlyDefined="true" PrivateAssets="all" Publish="true" />
  </ItemGroup>

</Project>
```

For alternative ways to include _coverlet_ into yout test project see also [coverlet-coverage/coverlet: Cross platform code coverage for .NET (github.com)](https://github.com/coverlet-coverage/coverlet#Quick-Start).

## How can set-up __*ReportGenerator*__?

In keeping with above to include [ReportGenerator](https://www.nuget.org/packages/ReportGenerator) by [MSBuild .targets Files - Visual Studio | Microsoft Docs](https://docs.microsoft.com/visualstudio/msbuild/msbuild-dot-targets-files).

``` xml
<?xml version="1.0" encoding="utf-8"?>
<Project>

  <ItemGroup>
    <PackageReference Include="ReportGenerator" Version="$(ReportGeneratorVersion)" IsImplicitlyDefined="true" PrivateAssets="all" Publish="true" />
  </ItemGroup>

  <Target Name="GenerateCoverageReport" AfterTargets="GenerateCoverageResultAfterTest">
    <ItemGroup>
      <CoverageFiles Include="$(ArtifactsCoverageDir)\$(MSBuildProjectName).xml" />
    </ItemGroup>

    <ReportGenerator ProjectDirectory="$(MSBuildProjectDirectory)" ReportFiles="@(CoverageFiles)" TargetDirectory="$(ArtifactsReportDir)\$(MSBuildProjectName)\Reports" ReportTypes="Html;Latex" HistoryDirectory="$(ArtifactsReportDir)\$(MSBuildProjectName)\History" VerbosityLevel="Verbose" />
  </Target>

</Project>
```

Also this tool offer a various way to use it, you can find all ways onto official documentation [ReportGenerator - converts coverage reports generated by coverlet](https://danielpalme.github.io/ReportGenerator/).

## How to wire-up all that?

To make everything work we need to add another _MSBuild_ file.

``` xml
<?xml version="1.0" encoding="utf-8"?>
<Project>

  <PropertyGroup>
    <VSTestLogger>trx</VSTestLogger>
    <VSTestResultsDirectory>$(ArtifactsTestResultsDir)</VSTestResultsDirectory>
  </PropertyGroup>

  <Import Project="CollectCoverage.targets" />
  <Import Project="ReportGenerator.targets" />

</Project>
```

And include this into your test project, something like this

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>

  <Import Project="Tests.targets" />
  
</Project>
```

Now everything you are able to run `dotnet test` you will able to inspect and analyze something like this

{{< figure src=https://camo.githubusercontent.com/adbd81e4a37adb003d75ecc13d508acda0c7aebc/68747470733a2f2f64616e69656c70616c6d652e6769746875622e696f2f5265706f727447656e657261746f722f7265736f75726365732f73637265656e73686f74312e706e67 alt="Example of coverage report" >}}

{{< figure src=https://camo.githubusercontent.com/adbd81e4a37adb003d75ecc13d508acda0c7aebc/68747470733a2f2f64616e69656c70616c6d652e6769746875622e696f2f5265706f727447656e657261746f722f7265736f75726365732f73637265656e73686f74312e706e67 alt="Example of coverage report for a single file" >}}

I think that is an amazing tool to understand at a glance which codes are covered and which not.

## And now, how I can put it into Azure DevOps pipeline?

It would be nice if this report came was published into the _Build pipeline_ report, don't you think? Maybe even include branch policies for it.

Well that's possible by use [Publish Code Coverage Results task](https://docs.microsoft.com/azure/devops/pipelines/tasks/test/publish-code-coverage-results), something like this:

```yaml
- task: PublishCodeCoverageResults@1
  displayName: Publish Code Coverage Results
  inputs:
    codeCoverageTool: 'cobertura'
    summaryFileLocation: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)/Reports/Summary/Cobertura.xml'
  continueOnError: true
  condition: always()
```

We notice the `summaryFileLocation` argument, this means that we will push only one file to _Azure DevOps_ why?

One unwrite note of _Publish Code Coverage Results task_ or limitation, I don't know, is that the sum of covered lines, when we publish more reports, is take from the first file

{{< figure src=pipeline-run-summary.png alt="Glance to summary code coverage percentage reported by Azure DevOps" >}}

This results in an unreliable result.

To fix that problem we can marge multiple reports into a summary reports so that can be publish it only one. One way to make it is the follow

``` xml
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk" DefaultTargets="GenerateSummaryCoverageReport" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>

  <UsingTask TaskName="ReportGenerator" AssemblyFile="$(NuGetPackageRoot)reportgenerator\$(ReportGeneratorVersion)\tools\$(TargetFramework)\ReportGenerator.MSBuild.dll" />

  <Target Name="GenerateSummaryCoverageReport" DependsOnTargets="Restore">
    <ItemGroup>
      <CoverageFiles Include="$(ArtifactsCoverageDir)\*.xml" />
    </ItemGroup>

    <ReportGenerator ProjectDirectory="$(MSBuildProjectDirectory)" ReportFiles="@(CoverageFiles)" TargetDirectory="$(ArtifactsTestResultsDir)\Reports\Summary" ReportTypes="Cobertura" />
  </Target>

</Project>
```

and run _MSBuild_ project into the pipeline with

```yaml
- script: dotnet msbuild SummaryReportGenerator.proj /p:Configuration=$(Configuration)
  name: GenerateCodeCoverageSummary
  displayName: Generate code coverage summary
```

Once you've done this the sum of covered lines on _Build pipeline_ will true.

## The greenfield approch.

All above is fully automated into [MsBullet](https://github.com/binick/msbullet) from version 0.6.1.

If you are approaching a greenfield then you might find this [getting started](https://binick.blog/msbullet/#getting-started) useful.

If, on the other hand, you are intent on using it in a brownfield and need some tips, leave a comment below.  
If you need to share sensitive information feel free to contact me privately! 
