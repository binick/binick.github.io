[{"content":"In un articolo precedente abbiamo visto Arricchire token JWT emessi da Azure Active Directory B2C.\nIn quell\u0026rsquo;articolo abbiamo parlato di come sia possibile aggiungere ad un JWT informazioni esterne a Microsoft Graph mediante l\u0026rsquo;uso di una Logic App ed un Blob Storage.\nIn questo invece vedremo come sia possibile creare una soluzioni che integri Azure Active Directory B2C.\nSeguendo la traccia di quanto trattato nel precedente articolo vedremo come salvare su Blob Storage dati fittizi alla registrazione di un utente.\nNote Nel resto dell\u0026rsquo;articolo ci sono riferimenti a risorse e concetti trattati nel precedente articolo al quale si rimanda. \nPanoramica della soluzione. La soluzione è cosi composta:\n Composizione della soluzione\n   read-customer-details-identity-la: rappresenta l\u0026rsquo;api il cui scopo è reperire il contenuto del blob da customersstgacc (lo storage account) customer-register-tpc: è il topic nel quale sono collezionati gli eventi di creazione di un nuovo utente customer-identity-details-filler-la: rappresenta l\u0026rsquo;api al quale spetta l\u0026rsquo;onere di generare dati fittizi che poi saranno salvati all\u0026rsquo;interno di un blob sullo customersstgacc   contoso-b2c: è il servizio di gestione degli accessi e delle identità offerto da Azure  Introduzione ad Azure Event Grid. In Azure esiste un\u0026rsquo;implementazione del pattern publish/subscribe concepita per agevolare l\u0026rsquo;integrazione e la gestione delle risorse mediante un paradigma di sviluppo ad eventi.\nMediante Event Grid sarà quindi possibile sottoscriversi a sorgenti di messaggi built-in attraverso una serie di gestori.\nQual\u0026rsquo;ora questo non fosse sufficiente è comunque possibile creare dei topic personalizzati ai quali sarà possibile sottoscriversi per riceverne gli eventi.\nCreazione di un topic personalizzato. Per la creazione di un topic è possibile fare riferimento a questa guida.\nUna scelta da fare al momento della creazione del topic riguarda lo schema del contenuto della richiesta HTTP utilizzato. Gli schemi supportati al momento sono:\n Event Grid Schema Cloud Event Schema Custom Input Schema, questo schema richiederà la creazione di un'associazione fra le proprietà dell\u0026rsquo;oggetto in ingresso e quelle richieste dallo Event Grid Schema.  Il messaggio usato in questo caso ha la seguente struttura\n1[ 2 { 3 \u0026#34;data\u0026#34;: { 4 \u0026#34;objectId\u0026#34;: \u0026#34;25100647-****-4571-****-b03e4ce72d02\u0026#34; // l\u0026#39;identificativo utile ad identificare l\u0026#39;utente 5 }, 6 \u0026#34;id\u0026#34;: \u0026#34;25100647-****-4571-****-b03e4ce72d02\u0026#34;, // l\u0026#39;identificativo univoco del messaggio, lo stesso di `data.objectId` in qesto caso 7 \u0026#34;eventType\u0026#34;: \u0026#34;Microsoft.ActiveDirectory\u0026#34;, 8 \u0026#34;subject\u0026#34;: \u0026#34;*.onmicrosoft.com\u0026#34;, 9 \u0026#34;dataVersion\u0026#34;: \u0026#34;1.0\u0026#34;, 10 \u0026#34;metadataVersion\u0026#34;: \u0026#34;1\u0026#34;, 11 \u0026#34;eventTime\u0026#34;: \u0026#34;2021-12-03T21:04:03.8504745Z\u0026#34;, 12 \u0026#34;topic\u0026#34;: \u0026#34;/subscriptions/{your-subscription-id}/resourceGroups/{your-resource-group}/providers/Microsoft.EventGrid/topics/{your-event-grid-topic}\u0026#34; 13 } 14] Emissione dell\u0026rsquo;evento di registrazione. L\u0026rsquo;invio degli eventi verso il topic avviene utilizzando un RESTful technical profile.\n1\u0026lt;TechnicalProfile Id=\u0026#34;AAD-UserEmitRegistrationEvent\u0026#34;\u0026gt; 2 \u0026lt;DisplayName\u0026gt;Emit user registration event to Event Grid.\u0026lt;/DisplayName\u0026gt; 3 \u0026lt;Protocol Name=\u0026#34;Proprietary\u0026#34; Handler=\u0026#34;Web.TPEngine.Providers.RestfulProvider, Web.TPEngine, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0026#34; /\u0026gt; 4 \u0026lt;Metadata\u0026gt; 5 \u0026lt;Item Key=\u0026#34;ServiceUrl\u0026#34;\u0026gt;{Settings:CustomerRegisteredTopicUrl}\u0026lt;/Item\u0026gt; 6 \u0026lt;Item Key=\u0026#34;AuthenticationType\u0026#34;\u0026gt;ApiKeyHeader\u0026lt;/Item\u0026gt; 7 \u0026lt;Item Key=\u0026#34;SendClaimsIn\u0026#34;\u0026gt;Body\u0026lt;/Item\u0026gt; 8 \u0026lt;Item Key=\u0026#34;ClaimUsedForRequestPayload\u0026#34;\u0026gt;userRegisterEvent\u0026lt;/Item\u0026gt; 9 \u0026lt;Item Key=\u0026#34;DefaultUserMessageIfRequestFailed\u0026#34;\u0026gt;Cannot process your request right now, please try again later.\u0026lt;/Item\u0026gt; 10 \u0026lt;/Metadata\u0026gt; 11 \u0026lt;CryptographicKeys\u0026gt; 12 \u0026lt;Key Id=\u0026#34;aeg-sas-key\u0026#34; StorageReferenceId=\u0026#34;B2C_1A_CustomerRegisteredTopicSas\u0026#34; /\u0026gt; 13 \u0026lt;/CryptographicKeys\u0026gt; 14 \u0026lt;InputClaimsTransformations\u0026gt; 15 \u0026lt;InputClaimsTransformation ReferenceId=\u0026#34;GetSystemDateTime\u0026#34; /\u0026gt; 16 \u0026lt;InputClaimsTransformation ReferenceId=\u0026#34;GenerateRegistrationEventRequest\u0026#34; /\u0026gt; 17 \u0026lt;/InputClaimsTransformations\u0026gt; 18 \u0026lt;InputClaims\u0026gt; 19 \u0026lt;InputClaim ClaimTypeReferenceId=\u0026#34;userRegisterEvent\u0026#34; /\u0026gt; 20 \u0026lt;/InputClaims\u0026gt; 21 \u0026lt;PersistedClaims\u0026gt; 22 \u0026lt;PersistedClaim ClaimTypeReferenceId=\u0026#34;systemDateTime\u0026#34; /\u0026gt; 23 \u0026lt;/PersistedClaims\u0026gt; 24 \u0026lt;UseTechnicalProfileForSessionManagement ReferenceId=\u0026#34;SM-AAD\u0026#34; /\u0026gt; 25\u0026lt;/TechnicalProfile\u0026gt; Questo frammento di markup tradotto in comando curl, per maggiore esplicabilità, risulterebbe cosi:\n1curl -X POST -H \u0026#34;aeg-sas-key: $key\u0026#34; -d \u0026#34;$event\u0026#34; $endpoint dove i requisiti di autenticazione vengono soddisfatti dal metadato AuthenticationType al quale viene associata la chiave crittografica aeg-sas-key il cui valore viene recuperato dalla chiave B2C_1A_CustomerRegisteredTopicSas presente nella collezione delle chiavi dei criteri.\nTL;DR La scelta dello schema del topic in questo esempio è stata guidata dalle limitazioni al momento imposte dal profilo tecnico RESTful riguardo alle possibilità di costruzione della richiesta HTTP, infatti per una combinazione di criteri non risulta possibile passare informazioni nelle intestazioni e nel corpo della richiesta allo stesso tempo.\nCiò rende impossibile inviare verso un topic schemi di tipo Cloud Event in quanto il protocollo, nella versione 1.0 richiede la presenza di un'intestazione obbligatoria. \nBen più complessa è la creazione del corpo della richiesta per la quale risultano necessario:\n utilizzare le InputClaimsTransformation aggiungere due attestazioni all\u0026rsquo;interno del bagaglio userRegisterEvent e systemDateTime entrambe di tipo stringa.  Infine il profilo tecnico è stato aggiunto fra i profili tecnici di validazione di LocalAccountSignUpWithLogonEmail in modo tale che l\u0026rsquo;evento venga emesso solamente in fase di registrazione di un\u0026rsquo;utente.\nUtilizzo delle trasformazioni delle attestazioni. Durante la creazione di criteri personalizzati potremmo avere la necessità di eseguire calcoli, come ad esempio il numero di tentativi di autenticazione, che seppur molto semplici risulterebbero impossibili senza l\u0026rsquo;esecuzioni di funzioni.\nQuesto requisito trova espressività tramite le ClaimsTransformation il cui riferimento delle trasformazioni delle attestazioni contiene la lista completa delle trasformazioni utilizabili.\nNell\u0026rsquo;esempio sono stati utilizzati i metodi GetCurrentDateTime e GenerateJson\n1\u0026lt;ClaimsTransformation Id=\u0026#34;GetSystemDateTime\u0026#34; TransformationMethod=\u0026#34;GetCurrentDateTime\u0026#34;\u0026gt; 2 \u0026lt;OutputClaims\u0026gt; 3 \u0026lt;OutputClaim ClaimTypeReferenceId=\u0026#34;systemDateTime\u0026#34; TransformationClaimType=\u0026#34;currentDateTime\u0026#34; /\u0026gt; 4 \u0026lt;/OutputClaims\u0026gt; 5\u0026lt;/ClaimsTransformation\u0026gt; GetSystemDateTime ha lo scopo di valorizzare l\u0026rsquo;attestazione systemDateTime\n1\u0026lt;ClaimsTransformation Id=\u0026#34;GenerateRegistrationEventRequest\u0026#34; TransformationMethod=\u0026#34;GenerateJson\u0026#34;\u0026gt; 2 \u0026lt;InputClaims\u0026gt; 3 \u0026lt;InputClaim ClaimTypeReferenceId=\u0026#34;objectId\u0026#34; TransformationClaimType=\u0026#34;0.data.objectId\u0026#34; /\u0026gt; 4 \u0026lt;InputClaim ClaimTypeReferenceId=\u0026#34;objectId\u0026#34; TransformationClaimType=\u0026#34;0.id\u0026#34; /\u0026gt; 5 \u0026lt;InputClaim ClaimTypeReferenceId=\u0026#34;systemDateTime\u0026#34; TransformationClaimType=\u0026#34;0.eventTime\u0026#34; /\u0026gt; 6 \u0026lt;/InputClaims\u0026gt; 7 \u0026lt;InputParameters\u0026gt; 8 \u0026lt;InputParameter Id=\u0026#34;0.dataVersion\u0026#34; DataType=\u0026#34;string\u0026#34; Value=\u0026#34;1.0\u0026#34; /\u0026gt; 9 \u0026lt;InputParameter Id=\u0026#34;0.eventType\u0026#34; DataType=\u0026#34;string\u0026#34; Value=\u0026#34;Microsoft.ActiveDirectory\u0026#34; /\u0026gt; 10 \u0026lt;InputParameter Id=\u0026#34;0.subject\u0026#34; DataType=\u0026#34;string\u0026#34; Value=\u0026#34;{Settings:Tenant}\u0026#34; /\u0026gt; 11 \u0026lt;/InputParameters\u0026gt; 12 \u0026lt;OutputClaims\u0026gt; 13 \u0026lt;OutputClaim ClaimTypeReferenceId=\u0026#34;userRegisterEvent\u0026#34; TransformationClaimType=\u0026#34;outputClaim\u0026#34; /\u0026gt; 14 \u0026lt;/OutputClaims\u0026gt; 15\u0026lt;/ClaimsTransformation\u0026gt; GenerateRegistrationEventRequest ha invece l\u0026rsquo;onere di costruire il JSON e valorizzare l\u0026rsquo;attestazione userRegisterEvent.\nConclusioni. In questo articolo abbiamo visto come mediante Identity Experience Framework sia possibile integrare un tenant B2C con la nostra infrastruttura ed aprire eventuali scenari di sviluppo interessanti.\nPer farlo abbiamo toccato Azure Event Grid e come creare un Event Grid Topic.\nInfine come sia possibile manipolare delle attestazioni ed utilizzarle all\u0026rsquo;interno dei profili tecnici.\nSe foste interessati all’esempio completo lo potrete trovare al seguente indirizzo https://github.com/binick/samples/tree/master/src/enrich-a-jwt-token-with-ief.\n","permalink":"https://binick.github.io/it/2022/01/08/aadb2c-subscribe-to-user-registration-event/","summary":"In un articolo precedente abbiamo visto Arricchire token JWT emessi da Azure Active Directory B2C.\nIn quell\u0026rsquo;articolo abbiamo parlato di come sia possibile aggiungere ad un JWT informazioni esterne a Microsoft Graph mediante l\u0026rsquo;uso di una Logic App ed un Blob Storage.\nIn questo invece vedremo come sia possibile creare una soluzioni che integri Azure Active Directory B2C.\nSeguendo la traccia di quanto trattato nel precedente articolo vedremo come salvare su Blob Storage dati fittizi alla registrazione di un utente.","title":"Sviluppare soluzioni integrate con Active Directory B2C ed Azure Event Grid."},{"content":"From the first basics in Pascal through Qt and QML, C# and SQL. Nicola is a full-stack code cleanliness maniac driven by the five SOLID principles.\nHis workbench is managed by chocolatey.org, wsl, and pwsh.\nPassionate about containerization, cloud, and CI/CD processes he is also a strong supporter of TDD, throughout his career he has worked in both web-based and desktop/mobile environments.\nHe strongly believes in OSS to which he tries to contribute regularly.\n","permalink":"https://binick.github.io/it/about-me/","summary":"Chi sono","title":"Chi sono"}]